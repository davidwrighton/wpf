<Project>

  <!-- Only enable API Compat against .NET Framework 4.8 when needed for some building assembly -->
  <PropertyGroup Condition="'$(RunNetFrameworkApiCompat)'==''">
    <RunNetFrameworkApiCompat>false</RunNetFrameworkApiCompat>
    <RunNetFrameworkApiCompat Condition="'$(Net48CompatNeededProjects)'!='' 
                                          and $(Net48CompatNeededProjects.Contains('$(MSBuildProjectName)'))
                                          and !($(MSBuildProjectName.Contains('_wpftmp')))">true</RunNetFrameworkApiCompat>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Turn off default API Compat targets in favor of WPF ones. -->
    <RunApiCompat>false</RunApiCompat>

    <RunWpfApiCompat>false</RunWpfApiCompat>
    <RunWpfApiCompat Condition="'$(RunNetFrameworkApiCompat)'=='true'">true</RunWpfApiCompat>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.DotNet.ApiCompat" Version="$(MicrosoftDotNetApiCompatVersion)" GeneratePathProperty="true" Condition="'$(RunWpfApiCompat)'=='true'"/>
  </ItemGroup>

  <!-- This target sets up the matching contracts to run ApiCompat from .NET Core assemblies against the .NET Framework 4.8 reference assemblies. -->
  <Target Name="ResolveNetFrameworkApiCompatItems"
          BeforeTargets="WpfValidateApiCompatForSrc"
          Condition="'$(RunNetFrameworkApiCompat)'=='true'">
    <PropertyGroup>
      <ApiCompatBaseline>$(WpfApiCompatBaselineDir)$(MSBuildProjectName)-Net48.baseline.txt</ApiCompatBaseline>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedMatchingContract Include="$(Net48RefAssembliesDir)$(AssemblyName).dll" />

      <!-- If building a hand-crafted ref assembly, compare against the current output.  Otherwise, use the ref directory (compiler generated ref). -->
      <ResolvedImplementationAssembly Include="$(IntermediateOutputPath)$(AssemblyName).dll" Condition="!Exists('$(IntermediateOutputPath)ref\$(AssemblyName).dll')" />
      <ResolvedImplementationAssembly Include="$(IntermediateOutputPath)ref\$(AssemblyName).dll" Condition="Exists('$(IntermediateOutputPath)ref\$(AssemblyName).dll')" />
    </ItemGroup>
  </Target>

  <!-- 
       The below is a modified version of Arcade's ApiCompat targets file.
       https://github.com/dotnet/arcade/blob/master/src/Microsoft.DotNet.ApiCompat/build/Microsoft.DotNet.ApiCompat.targets
       
       We use a custom version to provide greater control over which assembly pairs are being examined.
  -->

  <PropertyGroup>
    <!-- If DotNetTool is undefined, we default to assuming 'dotnet' is on the path -->
    <DotNetTool Condition="'$(DotNetTool)' == ''">dotnet</DotNetTool>

    <_ApiCompatPath Condition="'$(MSBuildRuntimeType)' == 'core'">$(PkgMicrosoft_DotNet_ApiCompat)\tools\netcoreapp2.1\Microsoft.DotNet.ApiCompat.dll</_ApiCompatPath>
    <_ApiCompatPath Condition="'$(MSBuildRuntimeType)' != 'core'">$(PkgMicrosoft_DotNet_ApiCompat)\tools\net472\Microsoft.DotNet.ApiCompat.exe</_ApiCompatPath>

    <_ApiCompatCommand Condition="'$(MSBuildRuntimeType)' == 'core'">"$(DotNetTool)" "$(_ApiCompatPath)"</_ApiCompatCommand>
    <_ApiCompatCommand Condition="'$(MSBuildRuntimeType)' != 'core' and '$(OS)' == 'Windows_NT'">"$(_ApiCompatPath)"</_ApiCompatCommand>
    <_ApiCompatCommand Condition="'$(MSBuildRuntimeType)' != 'core' and '$(OS)' != 'Windows_NT'">mono --runtime=v4.0.30319 "$(_ApiCompatPath)"</_ApiCompatCommand>

    <_ApiCompatSemaphoreFile>$(MSBuildThisFileName).semaphore</_ApiCompatSemaphoreFile>
  </PropertyGroup>

  <PropertyGroup Condition="'$(RunWpfApiCompat)' == 'true'">
    <_apiCompatTargetSuffix>$(TargetGroup)</_apiCompatTargetSuffix>
    <_apiCompatTargetSuffix Condition="'$(_apiCompatTargetSuffix)' == ''">$(TargetFramework)</_apiCompatTargetSuffix>

    <ApiCompatBaseline Condition="!Exists('$(ApiCompatBaseline)')">$(MSBuildProjectDirectory)\ApiCompatBaseline.$(_apiCompatTargetSuffix).txt</ApiCompatBaseline>
    <ApiCompatBaseline Condition="!Exists('$(ApiCompatBaseline)')">$(MSBuildProjectDirectory)\ApiCompatBaseline.txt</ApiCompatBaseline>

    <TargetsTriggeredByCompilation Condition="'$(RunWpfApiCompat)' == 'true'">$(TargetsTriggeredByCompilation);WpfValidateApiCompatForSrc</TargetsTriggeredByCompilation>
  </PropertyGroup>

  <ItemGroup>
    <CustomAdditionalCompileInputs Condition="Exists('$(IntermediateOutputPath)$(_ApiCompatSemaphoreFile)')" Include="$(IntermediateOutputPath)$(_ApiCompatSemaphoreFile)" />
  </ItemGroup>

  <!-- 
      ApiCompat for Implementation Assemblies.  
    
      Modified for WPF to take a specific ResolvedImplementationAssembly item.  This allows ApiCompat on generated ref assemblies
      vs .NET Framework 4.8 and also on any two specific assemblies.  This is important for both hand-crafted ref assemblies and for cycle-breakers.
  -->
  <Target Name="WpfValidateApiCompatForSrc"
          Condition="'$(RunWpfApiCompat)' == 'true'">

    <Error Condition="'@(ResolvedImplementationAssembly)' == ''"
        Text="ResolvedImplementationAssembly item must be specified to run API compat." />
    <Error Condition="!Exists('%(ResolvedImplementationAssembly.FullPath)')"
           Text="ResolvedImplementationAssembly '%(ResolvedImplementationAssembly.FullPath)' did not exist." />
    <Error Condition="'@(ResolvedMatchingContract)' == ''"
           Text="ResolvedMatchingContract item must be specified to run API compat." />
    <Error Condition="!Exists('%(ResolvedMatchingContract.FullPath)')"
           Text="ResolvedMatchingContract '%(ResolvedMatchingContract.FullPath)' did not exist." />

    <ItemGroup>
      <_DependencyDirectoriesTemp Include="@(ReferencePath -> '%(RootDir)%(Directory)')" />
      <!-- Remove duplicate directories by batching over them -->
      <!-- Add project references first to give precedence to project-specific files -->
      <_DependencyDirectories Condition="'%(_DependencyDirectoriesTemp.ReferenceSourceTarget)' == 'ProjectReference'" Include="%(_DependencyDirectoriesTemp.Identity)" />
      <_DependencyDirectories Condition="'%(_DependencyDirectoriesTemp.ReferenceSourceTarget)' != 'ProjectReference'" Include="%(_DependencyDirectoriesTemp.Identity)" />
      <_ContractDependencyDirectories Include="@(ResolvedMatchingContract -> '%(RootDir)%(Directory)')" />
      <_ContractDependencyDirectories Include="@(ResolvedMatchingContract -> '%(DependencyPaths)')" />
      <_ContractDependencyDirectories Include="$(ContractDependencyPaths)" />
    </ItemGroup>

    <PropertyGroup>
      <ApiCompatArgs>$(ApiCompatArgs) "@(ResolvedMatchingContract)"</ApiCompatArgs>
      <ApiCompatArgs>$(ApiCompatArgs) --contract-depends "@(_ContractDependencyDirectories, ','),"</ApiCompatArgs>
      <ApiCompatArgs Condition="'$(ApiCompatExcludeAttributeList)' != ''">$(ApiCompatArgs) --exclude-attributes "$(ApiCompatExcludeAttributeList)"</ApiCompatArgs>
      <ApiCompatArgs Condition="'$(ApiCompatEnforceOptionalRules)' == 'true'">$(ApiCompatArgs) --enforce-optional-rules</ApiCompatArgs>
      <ApiCompatArgs Condition="'$(BaselineAllAPICompatError)' != 'true' and Exists('$(ApiCompatBaseline)')">$(ApiCompatArgs) --baseline "$(ApiCompatBaseline)"</ApiCompatArgs>
      <!-- Must be last option. -->
      <ApiCompatArgs>$(ApiCompatArgs) --impl-dirs "@(ResolvedImplementationAssembly -> '%(RootDir)%(Directory)'),@(_DependencyDirectories, ','),"</ApiCompatArgs>
      <ApiCompatBaselineAll Condition="'$(BaselineAllAPICompatError)' == 'true'">&gt; $(ApiCompatBaseline)</ApiCompatBaselineAll>
      <ApiCompatExitCode>0</ApiCompatExitCode>

      <ApiCompatResponseFile>$(IntermediateOutputPath)apicompat.rsp</ApiCompatResponseFile>
    </PropertyGroup>

    <MakeDir Directories="$(IntermediateOutputPath)" />
    <WriteLinesToFile File="$(ApiCompatResponseFile)" Lines="$(ApiCompatArgs)" Overwrite="true" />

    <Exec Command="$(_ApiCompatCommand) @&quot;$(ApiCompatResponseFile)&quot; $(ApiCompatBaselineAll)"
          CustomErrorRegularExpression="^[a-zA-Z]+ :"
          StandardOutputImportance="Low"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="ApiCompatExitCode" />
    </Exec>

    <!--
      To force incremental builds to show failures again we are invalidating
      one compile input.
    -->
    <Touch Condition="'$(ApiCompatExitCode)' != '0'" Files="$(IntermediateOutputPath)$(_ApiCompatSemaphoreFile)" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
    <Error Condition="'$(ApiCompatExitCode)' != '0'" Text="ApiCompat failed for '$(TargetPath)'" />
  </Target>

</Project>
